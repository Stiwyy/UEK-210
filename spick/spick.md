# Kubernetes & Cloud Computing - Pr√ºfungsspick

# Inhaltsverzeichnis

1. [Command Reference: Minikube, kubectl & oc](#1-command-reference-minikube-kubectl--oc)
   - [Minikube Commands (Lokales Kubernetes Cluster)](#-minikube-commands-lokales-kubernetes-cluster)
   - [kubectl Commands (Kubernetes CLI)](#-kubectl-commands-kubernetes-cli)
   - [oc Commands (OpenShift CLI)](#-oc-commands-openshift-cli)
   - [Debugging-Workflow](#debugging-workflow)

2. [YAML Files f√ºr Kubernetes Components](#2-yaml-files-f√ºr-kubernetes-components)
   - [Grundaufbau einer Kubernetes YAML-Datei](#grundaufbau-einer-kubernetes-yaml-datei)
   - [Metadata Specifications](#metadata-specifications)

3. [Kubernetes Components](#3-kubernetes-components)
   - [Pod](#pod)
   - [Deployment](#deployment)
   - [Service](#service)
   - [ReplicaSet](#replicaset)
   - [StatefulSet](#statefulset)
   - [DaemonSet](#daemonset)
   - [Namespace](#namespace)
   - [Ingress](#ingress)
   - [PersistentVolume (PV) & PersistentVolumeClaim (PVC)](#persistentvolume-pv--persistentvolumeclaim-pvc)

4. [Cloud Computing - Grundlagen](#4-cloud-computing---grundlagen)
   - [Wie ist der Begriff Cloud entstanden?](#wie-ist-der-begriff-cloud-entstanden)
   - [NIST Definition der Cloud](#nist-definition-der-cloud)

5. [Die 5 Merkmale einer Cloud](#5-die-5-merkmale-einer-cloud)

6. [Cloud Dienstleistungen](#6-cloud-dienstleistungen)

7. [Cloud Anbieter](#7-cloud-anbieter)

8. [Cloud Deployment Modelle](#8-cloud-deployment-modelle)

9. [Cloud Service Modelle](#9-cloud-service-modelle)

10. [Monitoring vs. Logging](#10-monitoring-vs-logging)

11. [Cloud - Vorteile & Nachteile](#11-cloud---vorteile--nachteile)

12. [Shared Responsibility Model](#12-shared-responsibility-model)

13. [Container-Technologie](#13-container-technologie)
    - [Was ist Container-Technologie?](#was-ist-container-technologie)
    - [Container vs. Virtuelle Maschinen](#container-vs-virtuelle-maschinen)
    - [K√∂nnen VMs immer durch Container ersetzt werden?](#k√∂nnen-vms-immer-durch-container-ersetzt-werden)

14. [Produkte f√ºr VMs & Container](#14-produkte-f√ºr-vms--container)

15. [Self-Managed vs. Fully Managed](#15-self-managed-vs-fully-managed)

16. [Container-Orchestrierung](#16-container-orchestrierung)
    - [Warum braucht man Container-Orchestrierung?](#warum-braucht-man-container-orchestrierung)
    - [Wie funktioniert Container-Orchestrierung?](#wie-funktioniert-container-orchestrierung)
    - [Container-Orchestrierung Technologien](#container-orchestrierung-technologien)

17. [Horizontale Skalierung](#17-horizontale-skalierung)

18. [Deployment Strategien](#18-deployment-strategien)

19. [Fragen zu Block 7](#19-fragen-zu-block-7)

## 1. Command Reference: Minikube, kubectl & oc

### üî∑ Minikube Commands (Lokales Kubernetes Cluster)

#### Cluster Management
```bash
# Minikube starten
minikube start
minikube start --driver=docker          # Mit Docker Driver

# Minikube stoppen
minikube stop

# Minikube l√∂schen
minikube delete
minikube delete --all                   # Alle Profile l√∂schen

# Cluster-Status anzeigen
minikube status

```

#### Cluster-Informationen
```bash
# Kubernetes Dashboard √∂ffnen
minikube dashboard

# Cluster IP anzeigen
minikube ip

# Minikube Logs
minikube logs

```
---

### üî∑ kubectl Commands (Kubernetes CLI)

#### Cluster-Informationen
```bash
# Cluster-Info anzeigen
kubectl cluster-info
kubectl cluster-info dump               # Detaillierte Cluster-Informationen

# Nodes anzeigen
kubectl get nodes
kubectl get nodes -o wide               # Mit mehr Details
kubectl describe node <node-name>

# Konfiguration anzeigen
kubectl config view
kubectl config get-contexts             # Alle Contexts
kubectl config current-context          # Aktueller Context
kubectl config use-context <context>    # Context wechseln
```

#### Ressourcen anzeigen (GET)
```bash
# Pods
kubectl get pods
kubectl get pods -n <namespace>         # In bestimmtem Namespace
kubectl get pods --all-namespaces       # Alle Namespaces (oder -A)
kubectl get pods -o wide                # Mehr Details (Node, IP)
kubectl get pods -o yaml                # YAML-Output
kubectl get pods -o json                # JSON-Output
kubectl get pods --watch                # Live-Updates (oder -w)
kubectl get pods --show-labels          # Mit Labels
kubectl get pods -l app=nginx           # Filter nach Label

# Andere Ressourcen
kubectl get deployments
kubectl get services (oder svc)
kubectl get replicasets (oder rs)
kubectl get namespaces (oder ns)
kubectl get configmaps (oder cm)
kubectl get secrets
kubectl get ingress (oder ing)
kubectl get persistentvolumes (oder pv)
kubectl get persistentvolumeclaims (oder pvc)
kubectl get statefulsets (oder sts)
kubectl get daemonsets (oder ds)

# Alle Ressourcen in einem Namespace
kubectl get all
kubectl get all -n <namespace>
```

#### Detaillierte Informationen (DESCRIBE)
```bash
# Details zu Ressourcen
kubectl describe pod <pod-name>
kubectl describe deployment <deployment-name>
kubectl describe service <service-name>
kubectl describe node <node-name>
kubectl describe pv <pv-name>

```

#### Logs & Debugging
```bash
# Logs anzeigen
kubectl logs <pod-name>
```

#### Erstellen & Anwenden (CREATE/APPLY)
```bash
# YAML-Datei anwenden
kubectl apply -f deployment.yaml
kubectl apply -f ./config-folder/         # Ganzer Ordner
kubectl apply -f https://raw.githubusercontent.com/.../file.yaml

```

#### L√∂schen (DELETE)
```bash
# Ressourcen l√∂schen
kubectl delete pod <pod-name>
kubectl delete deployment <deployment-name>
kubectl delete service <service-name>

# Mit Datei
kubectl delete -f deployment.yaml

# Nach Label
kubectl delete pods -l app=nginx

# Alle Pods in Namespace
kubectl delete pods --all
kubectl delete all --all                 # VORSICHT: L√∂scht alles!

# Namespace l√∂schen (l√∂scht alle Ressourcen darin)
kubectl delete namespace <namespace-name>

# Force delete (bei h√§ngenden Pods)
kubectl delete pod <pod-name> --grace-period=0 --force
```

---

### üî∑ oc Commands (OpenShift CLI)

**Hinweis:** `oc` basiert auf `kubectl` und hat alle kubectl-Befehle + OpenShift-spezifische Features.

#### Login & Authentifizierung
```bash
# Login in OpenShift Cluster
oc login <cluster-url>
oc login https://api.openshift.example.com:6443
oc login --token=<token> --server=<server-url>

# Login mit Username/Password
oc login -u <username> -p <password>

# Logout
oc logout

# Aktuellen User anzeigen
oc whoami
oc whoami --show-token                  # Token anzeigen
oc whoami --show-server                 # Server anzeigen
oc whoami --show-console                # Web-Console URL
```

#### Projekte (OpenShift Namespaces)
```bash
# Projekte anzeigen
oc projects
oc get projects

# Neues Projekt erstellen
oc new-project <project-name>
oc new-project dev-environment --description="Dev Env" --display-name="Development"

# Projekt wechseln
oc project <project-name>

# Aktuelles Projekt anzeigen
oc project

# Projekt l√∂schen
oc delete project <project-name>
```

#### Routes (OpenShift Ingress)
```bash
# Routes anzeigen
oc get routes
oc get route <route-name>

# Route l√∂schen
oc delete route <route-name>
```

#### N√ºtzliche oc-spezifische Features
```bash
# Alle Ressourcen eines Projekts anzeigen
oc get all
```

#### Conversion: kubectl ‚Üî oc
```bash
# Diese sind identisch:
kubectl get pods        = oc get pods
kubectl apply -f        = oc apply -f
kubectl logs            = oc logs
kubectl exec            = oc exec

# OpenShift-spezifisch (kein kubectl-√Ñquivalent):
oc new-app
oc new-project
oc expose
oc start-build
oc login
```

---

#### Debugging-Workflow
```bash
# 1. Pod-Status pr√ºfen
kubectl get pods

# 2. Details ansehen
kubectl describe pod <pod-name>

# 3. Logs pr√ºfen
kubectl logs <pod-name>

# 4. Events pr√ºfen
kubectl get events --sort-by='.lastTimestamp'

# 5. In Container gehen
kubectl exec -it <pod-name> -- /bin/sh

# 6. Netzwerk testen
kubectl run -it --rm debug --image=busybox --restart=Never -- sh
```

---

## 2. YAML Files f√ºr Kubernetes Components

### Grundaufbau einer Kubernetes YAML-Datei

```yaml
apiVersion: <version>
kind: <resource-type>
metadata:
  name: <resource-name>
  namespace: <namespace>
  labels:
    <key>: <value>
  annotations:
    <key>: <value>
spec:
  <resource-specific-configuration>
```

### Metadata Specifications

**Wichtige Metadata-Felder:**
- `name`: Eindeutiger Name der Ressource
- `namespace`: Logische Gruppierung (Standard: "default")
- `labels`: Key-Value-Paare f√ºr Selektion und Organisation
- `annotations`: Metadaten f√ºr Tools (nicht zur Selektion)
- `uid`: Automatisch generierte eindeutige ID
- `resourceVersion`: Interne Versionsnummer

**ConfigMap & Secrets:**
```yaml
# ConfigMap - f√ºr nicht-sensitive Daten
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  database_url: "postgres://db:5432"
  log_level: "info"

# Secret - f√ºr sensitive Daten (base64-kodiert)
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
type: Opaque
data:
  username: YWRtaW4=  # base64
  password: cGFzc3dvcmQ=
```

---

## 3. Kubernetes Components

### Pod
**Kleinste deploybare Einheit in Kubernetes**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    app: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    ports:
    - containerPort: 80
    env:
    - name: DB_HOST
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: database_url
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
```

**Eigenschaften:**
- Enth√§lt einen oder mehrere Container
- Teilen sich Netzwerk und Storage
- Verg√§nglich (Ephemeral)

---

### Deployment
**Verwaltet Replikation und Updates von Pods**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.21
        ports:
        - containerPort: 80
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
```

**Eigenschaften:**
- Gew√§hrleistet gew√ºnschte Anzahl Replicas
- Erm√∂glicht Rolling Updates
- Self-Healing bei Pod-Ausfall

---

### Service
**Netzwerk-Abstraktion f√ºr Pod-Zugriff**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  type: ClusterIP  # LoadBalancer, NodePort, ClusterIP
  selector:
    app: nginx
  ports:
  - protocol: TCP
    port: 80        # Service Port
    targetPort: 80  # Container Port
```

**Service-Typen:**
- **ClusterIP**: Intern erreichbar (Standard)
- **NodePort**: Extern √ºber Node-IP:Port
- **LoadBalancer**: Cloud Load Balancer
- **ExternalName**: DNS CNAME-Mapping

---

### ReplicaSet
**Stellt sicher, dass definierte Anzahl Pods l√§uft**

```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: nginx-replicaset
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.21
```

**Hinweis:** Wird meist durch Deployments verwaltet!

---

### StatefulSet
**F√ºr stateful Anwendungen (z.B. Datenbanken)**

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
spec:
  serviceName: postgres
  replicas: 3
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:13
        volumeMounts:
        - name: data
          mountPath: /var/lib/postgresql/data
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi
```

**Eigenschaften:**
- Stabile Netzwerk-Identit√§ten
- Persistente Storage
- Geordnetes Deployment/Scaling

---

### DaemonSet
**Stellt sicher, dass auf jedem Node ein Pod l√§uft**

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: monitoring-agent
spec:
  selector:
    matchLabels:
      app: monitoring
  template:
    metadata:
      labels:
        app: monitoring
    spec:
      containers:
      - name: agent
        image: monitoring-agent:latest
```

**Verwendung:** Logging, Monitoring, Netzwerk-Plugins

---

### Namespace
**Logische Trennung von Ressourcen**

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: production
```

---

### Ingress
**HTTP/HTTPS Routing zu Services**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: myapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx-service
            port:
              number: 80
```

---

### PersistentVolume (PV) & PersistentVolumeClaim (PVC)

```yaml
# PersistentVolume
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-data
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: standard
  hostPath:
    path: /mnt/data

---
# PersistentVolumeClaim
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-data
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: standard
```

---

## 4. Cloud Computing - Grundlagen

### Wie ist der Begriff Cloud entstanden?
**Darstellung des Internets und komplexer Netzwerke als eine Wolke**

### NIST Definition der Cloud
Ein Modell, das den **bedarfsgerechten, netzwerkbasierten Zugriff** auf einen gemeinsamen Pool **konfigurierbarer IT-Ressourcen** erm√∂glicht, die **schnell bereitgestellt** und mit **minimalem Verwaltungsaufwand** genutzt werden k√∂nnen.

---

## 5. Die 5 Merkmale einer Cloud

1. **On-Demand Self-Service**
   - Selbstst√§ndige Ressourcen-Bereitstellung ohne menschliche Interaktion

2. **Breiter Netzwerkzugang**
   - Zugriff √ºber Standard-Mechanismen (HTTP, APIs)
   - Von verschiedenen Ger√§ten (Laptop, Smartphone, etc.)

3. **Ressourcen-Pooling**
   - Multi-Tenant-Modell
   - Ressourcen dynamisch zugewiesen
   - Standortunabh√§ngigkeit

4. **Schnelle Elastizit√§t**
   - Automatische Skalierung nach Bedarf
   - Erscheint als unbegrenzt verf√ºgbar

5. **Gemessener Service (Metering)**
   - Ressourcen-Nutzung wird √ºberwacht und gemessen
   - Pay-per-Use Modell

---

## 6. Cloud Dienstleistungen

- **Webhosting** - Hosting von Websites/Anwendungen
- **Datenbankdienste** - Managed Databases (MySQL, PostgreSQL, NoSQL)
- **Speicherl√∂sungen** - Object Storage (S3), Block Storage
- **Virtuelle Maschinen** - Compute Instances
- **Backup & Recovery** - Automatisierte Sicherungen
- **KI-/ML-Dienste** - Machine Learning Platforms
- **Container-Services** - Kubernetes, Container Registry

---

## 7. Cloud Anbieter

- **AWS (Amazon Web Services)** - Marktf√ºhrer
- **Microsoft Azure** - Enterprise-Fokus
- **Google Cloud Platform (GCP)** - KI/ML stark
- **IBM Cloud** - Hybrid/Enterprise
- **Oracle Cloud** - Datenbank-fokussiert

---

## 8. Cloud Deployment Modelle

| Modell | Beschreibung | Vorteile | Nachteile |
|--------|-------------|----------|-----------|
| **Public Cloud** | √ñffentlich verf√ºgbar, Multi-Tenant | G√ºnstig, skalierbar | Weniger Kontrolle |
| **Private Cloud** | Dediziert f√ºr eine Organisation | Volle Kontrolle, Sicherheit | Teurer, weniger Skalierung |
| **Hybrid Cloud** | Kombination Public + Private | Flexibilit√§t, Best of Both | Komplex zu verwalten |
| **Community Cloud** | Gemeinsam genutzt von mehreren Orgs | Geteilte Kosten | Eingeschr√§nkte Kontrolle |

---

## 9. Cloud Service Modelle

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ SaaS - Software as a Service           ‚îÇ  ‚Üê Du verwaltest: NUR DATEN
‚îÇ (Gmail, Office 365, Salesforce)        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ PaaS - Platform as a Service           ‚îÇ  ‚Üê Du verwaltest: Anwendung + Daten
‚îÇ (Heroku, Google App Engine)            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ FaaS - Function as a Service           ‚îÇ  ‚Üê Du verwaltest: NUR CODE
‚îÇ (AWS Lambda, Azure Functions)          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ IaaS - Infrastructure as a Service     ‚îÇ  ‚Üê Du verwaltest: OS, Runtime, App
‚îÇ (AWS EC2, Azure VMs)                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**IaaS:** Virtuelle Maschinen, Netzwerk, Storage
**PaaS:** Entwicklungsplattform ohne Infrastruktur-Management
**SaaS:** Fertige Anwendung, nur nutzen
**FaaS:** Event-basierte Funktionen, Serverless

---

## 10. Monitoring vs. Logging

| Aspekt | Monitoring | Logging |
|--------|-----------|---------|
| **Fokus** | Leistung & Verf√ºgbarkeit | Detaillierte Ereignisse |
| **Daten** | Metriken (CPU, RAM, Response Time) | Log-Eintr√§ge (Fehler, Warnungen) |
| **Zeitraum** | Echtzeit, Trends | Historisch, Analyse |
| **Zweck** | Alarmierung, Dashboards | Debugging, Audit |
| **Tools** | Prometheus, Grafana, CloudWatch | ELK Stack, Splunk, Loki |

**Zusammenfassung:**
- **Logging** ist detailliert (Was ist passiert?)
- **Monitoring** beobachtet die Leistung (Wie l√§uft es?)

---

## 11. Cloud - Vorteile & Nachteile

### ‚úÖ Vorteile

- **G√ºnstiger** - Keine Hardware-Investitionen, Pay-per-Use
- **Weniger Arbeit** - Kein Datacenter-Management
- **Ausfallsicherheit** - Redundanz, hohe Verf√ºgbarkeit
- **Skalierbarkeit** - Elastisch nach Bedarf
- **Ortsunabh√§ngiger Zugriff** - Von √ºberall erreichbar

### ‚ùå Nachteile

- **Nicht volle Kontrolle** - Abh√§ngig vom Anbieter
- **Abh√§ngigkeit vom Anbieter** - Vendor Lock-in
- **Datenschutz-/Sicherheitsbedenken** - Daten bei Dritten
- **Internetverbindung notwendig** - Offline nicht nutzbar

---

## 12. Shared Responsibility Model

**Verteilung der Verantwortung auf Cloud-Anbieter und Kunden**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ KUNDE verantwortlich f√ºr:              ‚îÇ
‚îÇ - Daten & Inhalte                      ‚îÇ
‚îÇ - Anwendungen                          ‚îÇ
‚îÇ - Zugriffsverwaltung (IAM)             ‚îÇ
‚îÇ - Verschl√ºsselung                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ GEMEINSAM:                             ‚îÇ
‚îÇ - Patch Management                     ‚îÇ
‚îÇ - Konfiguration                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ANBIETER verantwortlich f√ºr:           ‚îÇ
‚îÇ - Physische Infrastruktur              ‚îÇ
‚îÇ - Netzwerk-Infrastruktur               ‚îÇ
‚îÇ - Hypervisor                           ‚îÇ
‚îÇ - Rechenzentrum-Sicherheit             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Variiert je nach Service-Modell (IaaS vs. SaaS)**

---

## 13. Container-Technologie

### Was ist Container-Technologie?

- **Anwendungen und alle ihre Abh√§ngigkeiten** in isolierte Softwarepakete verpacken
- **Leichtgewichtige Virtualisierung** auf Betriebssystem-Ebene
- **Nutzung des gleichen OS-Kernels**, aber getrennte Laufzeitumgebungen
- **Schnellere Bereitstellung** und Skalierbarkeit von Anwendungen

### Container vs. Virtuelle Maschinen

| Aspekt | Container | Virtuelle Maschine (VM) |
|--------|-----------|------------------------|
| **Bereitstellung** | Sekunden | Minuten |
| **Speicherplatz** | MB (nur App + Deps) | GB (komplettes OS) |
| **Portabilit√§t** | Hoch (l√§uft √ºberall) | Eingeschr√§nkt (Hypervisor) |
| **Effizienz** | H√∂her (direkter Zugriff) | Geringer (Hypervisor-Overhead) |
| **Kernel** | Gemeinsamer Host-Kernel | Eigener Kernel pro VM |
| **Isolation** | Schw√§cher (Kernel geteilt) | St√§rker (komplett getrennt) |
| **Startzeit** | < 1 Sekunde | 30-60 Sekunden |

### ‚úÖ Vorteile Container

- Geringerer Ressourcenverbrauch
- Schnellere Startzeiten
- H√∂here Portabilit√§t (unabh√§ngig von Infrastruktur)
- Bessere Skalierbarkeit

### ‚ùå Nachteile Container

- Schw√§chere Isolation (teilen sich den Kernel)
- Komplexere Netzwerkkonfiguration
- Geringerer Funktionsumfang bei vollst√§ndigen OS-Funktionen

### K√∂nnen VMs immer durch Container ersetzt werden?

**NEIN!**
- Bei Bedarf f√ºr unterschiedliche OS (Windows + Linux)
- Bei strikten Sicherheitsanforderungen (vollst√§ndige Isolation)
- Legacy-Anwendungen mit OS-spezifischen Anforderungen

---

## 14. Produkte f√ºr VMs & Container

### Container
- **Docker** - Standard Container-Runtime
- **Kubernetes (K8s)** - Container-Orchestrierung
- **Podman** - Daemonless Container Engine
- **AWS ECS/EKS** - Amazon Container Services
- **Azure Container Instances** - Serverless Container
- **Google Kubernetes Engine (GKE)** - Managed Kubernetes

### Virtuelle Maschinen
- **VMware vSphere / ESXi** - Enterprise Virtualisierung
- **VirtualBox** - Desktop-Virtualisierung
- **AWS EC2** - Cloud VMs
- **Azure Virtual Machines** - Microsoft Cloud VMs
- **Google Compute Engine** - Google Cloud VMs

---

## 15. Self-Managed vs. Fully Managed

### Self-Managed

**Definition:**
- Benutzer ist verantwortlich f√ºr Betrieb, Wartung und Updates
- Volle Kontrolle √ºber die Infrastruktur
- H√∂herer Aufwand bei Konfiguration und Sicherheit

**Beispiele:**
- Eigener Kubernetes-Cluster
- Selbst gehostete VMs
- On-Premise Datenbanken

### Fully Managed

**Definition:**
- Anbieter √ºbernimmt Betrieb, Wartung, Monitoring und Skalierung
- Reduzierter Administrationsaufwand
- Eingeschr√§nkte Anpassungsm√∂glichkeiten

**Beispiele:**
- AWS Fargate (Serverless Container)
- Google App Engine
- Azure App Services
- AWS RDS (Managed Database)

### Diskussion

**Entscheidungskriterien:**
- Verf√ºgbare Ressourcen & Know-how
- Ben√∂tigte Flexibilit√§t vs. Aufwand
- Kosten (OpEx vs. CapEx)
- Self-Managed: Mehr Kontrolle, aber aufw√§ndiger
- Fully Managed: Schneller einsatzbereit, weniger Einfluss

---

## 16. Container-Orchestrierung

### Warum braucht man Container-Orchestrierung?

- **Automatisierte Verwaltung** vieler Container
- **Skalierung** (horizontal), Load Balancing, Self-Healing
- **Updates ohne Downtime** (Rolling Updates)
- **Effiziente Nutzung** von Ressourcen
- **Service Discovery** & Networking

### Wie funktioniert Container-Orchestrierung?

1. **Deklarative Konfiguration** (z.B. YAML)
   - Gew√ºnschter Zustand wird definiert
   
2. **Scheduling auf Hosts**
   - Intelligente Verteilung auf verf√ºgbare Nodes

3. **Service Discovery & Networking**
   - Container finden sich automatisch

4. **Lastverteilung (Load Balancing)**
   - Traffic wird verteilt

5. **Auto-Recovery (Self-Healing)**
   - Neustart bei Fehlern

6. **Horizontal Scaling**
   - Automatische Anpassung der Replicas

### Container-Orchestrierung Technologien

- **Kubernetes (K8s)** - Industry Standard, sehr m√§chtig
- **Docker Swarm** - Einfacher, in Docker integriert
- **AWS ECS/EKS** - Amazon-eigene Orchestrierung

---

## 17. Horizontale Skalierung

**Definition:**
Mehrere Instanzen der Anwendung statt gr√∂√üerer Server

### Eigenschaften

- **Mehrere kleinere Instanzen** statt einem gro√üen Server
- **Bessere Lastverteilung** √ºber viele Nodes
- **H√∂here Verf√ºgbarkeit** (Ausfall einzelner Instanzen verkraftbar)
- **Elastisch anpassbar** (schnell hoch-/runterskalieren)

### Horizontal vs. Vertikal

```
Horizontal (Scale Out):          Vertikal (Scale Up):
‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îê               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ A ‚îÇ ‚îÇ A ‚îÇ ‚îÇ A ‚îÇ               ‚îÇ   A   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îò               ‚îÇ       ‚îÇ
Mehr Server                      ‚îÇ       ‚îÇ
                                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 Gr√∂√üerer Server
```

**Vorteil Horizontal:** Besser f√ºr Cloud & Container!

---

## 18. Deployment Strategien

### 1. Rolling Update (Schrittweises Ersetzen)
```
Alt: [V1] [V1] [V1] [V1]
     [V2] [V1] [V1] [V1]
     [V2] [V2] [V1] [V1]
     [V2] [V2] [V2] [V1]
Neu: [V2] [V2] [V2] [V2]
```
- ‚úÖ Keine Downtime
- ‚úÖ Ressourcen-effizient
- ‚ùå Gemischte Versionen tempor√§r

### 2. Blue-Green (Zwei Umgebungen, Umschaltung)
```
Blue (V1):  [V1] [V1] [V1]  ‚Üê Live Traffic
Green (V2): [V2] [V2] [V2]  ‚Üê Idle
            ‚Üì
            Switch Traffic
            ‚Üì
Blue (V1):  [V1] [V1] [V1]  ‚Üê Idle
Green (V2): [V2] [V2] [V2]  ‚Üê Live Traffic
```
- ‚úÖ Sofortiges Rollback
- ‚úÖ Keine Downtime
- ‚ùå Doppelte Ressourcen n√∂tig

### 3. Canary (Test mit kleinem Nutzeranteil)
```
V1: [V1] [V1] [V1] [V1]  ‚Üê 90% Traffic
V2: [V2]                  ‚Üê 10% Traffic
Wenn OK ‚Üí mehr Traffic zu V2
```
- ‚úÖ Risikominimierung
- ‚úÖ Echtes User-Feedback
- ‚ùå Komplexes Monitoring n√∂tig

### 4. Recreate (Stop + Start, Downtime)
```
[V1] [V1] [V1]  ‚Üí STOP ‚Üí [V2] [V2] [V2]
      ‚Üì
   Downtime!
```
- ‚úÖ Einfach
- ‚ùå Downtime
- Nur f√ºr nicht-kritische Apps

### 5. A/B Testing (Vergleich verschiedener Versionen)
```
V1: [V1] [V1]  ‚Üê 50% User
V2: [V2] [V2]  ‚Üê 50% User
(basierend auf User-Segment, nicht zuf√§llig)
```
- ‚úÖ Feature-Testing
- ‚úÖ Datengetriebene Entscheidungen
- ‚ùå Komplexe Analyse n√∂tig

### 6. Shadow (Neuer Code erh√§lt Traffic-Kopie)
```
V1: [V1]  ‚Üê Production Traffic
     ‚îÇ
     ‚îî‚îÄ‚Üí [V2]  ‚Üê Kopie des Traffics (keine Response an User)
```
- ‚úÖ Testen ohne Risiko
- ‚úÖ Realistische Last
- ‚ùå Doppelte Ressourcen

---

## 19. Fragen zu Block 7

*Was macht die Anwendung?*  
- Die Anwendung besteht aus einem Backend, das Zitate bereitstellt, einer React-Frontend-Seite, die die Zitate anzeigt, und einer MariaDB-Datenbank, in der die Zitate gespeichert sind.

*Welche Programmiersprache wird f√ºr das Backend verwendet?*  
- Python

*Welche Programmiersprache wird f√ºr das Frontend verwendet?*  
- React

---

*Wohin leitet die Route ihre Anfragen weiter?*  
- Die Route leitet ihre Anfragen √ºber den Service an das entsprechende Pod weiter.

*Wie weiss ein Service, an welche Pods er Anfragen weiterleiten muss?*  
- Der Service verwendet Labels, die den Pods zugewiesen sind, um zu bestimmen, welche Pods die Anfragen erhalten sollen. Dies geschieht √ºber Key-Value-Paare wie zum Beispiel app: quotes.

---

*Wer erstellt die Anfragen an das Backend? Das Frontend oder der Browser?*  
- Die Anfragen an das Backend werden vom Browser erstellt.

---

*Zu welcher Ressource leitet die Route die Anfrage weiter?*  
- Die Route leitet die Anfragen an den Service, der dann weiter an das passende Pod sendet.

*Wie weiss ein Service, welche Pods er ansprechen muss?*  
- Der Service verwendet Labels, die in den Pods definiert sind, um festzulegen, welche Pods die Anfragen erhalten. Diese Labels sind Key-Value-Paare wie z.B. app: quotes.

---

*Wer erstellt die Anfragen an das Backend? Das Frontend oder der Browser?*  
- Die Anfragen an das Backend werden vom Browser erstellt.

---

*Wie weiss das Backend, mit welcher Datenbank es sich verbinden soll?*  
- Das Backend verwendet eine Umgebungsvariable (DB_SERVICE_NAME), die den Namen des MariaDB-Dienstes enth√§lt, um die Verbindung zur richtigen Datenbank herzustellen.

---

*Was macht eine HPA (Horizontal Pod Autoscaler)?*  
- Eine HPA skaliert die Anzahl der Pods basierend auf der Auslastung der Ressourcen, z.B. der CPU-Auslastung.

*Warum kann eine HPA n√ºtzlich sein?*  
- Eine HPA erm√∂glicht es, die Anwendung automatisch zu skalieren, wenn die Auslastung zunimmt, und sorgt so f√ºr bessere Verf√ºgbarkeit und Leistung.

*Was k√∂nnte das Risiko beim Einsatz einer HPA sein?*  
- Ein Risiko beim Einsatz einer HPA besteht darin, dass eine zu aggressive Skalierung die Infrastruktur √ºberlasten oder zus√§tzliche Kosten verursachen kann.
